# -*- coding: utf-8 -*-
"""3a_Python.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1z-rAEzoeqTEuh2y-E69qThgJzAZfJ7Q-

> Bibliotecas
"""

import pandas as pd
import pathlib
import numpy as np                      #trab c numero
import seaborn as sns
import matplotlib.pyplot as plt         #gráficos
import plotly.express as px
from sklearn.metrics import r2_score, mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.ensemble import RandomForestRegressor, ExtraTreesRegressor
from sklearn.model_selection import train_test_split

'''
Se alguma biblioteca der probelma na importação:
- Abrir o prompt do Anaconda    -> não confundir com o prompt do pc
- Instalar com o pip
   > pip install pacote
'''

"""> input: pegar info do usuário
```
variavel = input('Pergunta para ser respondida')
```

> Comparadores
"""

'''
==    igual
!=    diferente
>     maior que (>= maior ou igual)
<     menor que (<= menor ou igual)
in    texto existe dentro de outro texto 
not   verifica o contrário da comparação
pass  se em alguma condição você não quiser fazer nada
'''

"""> Operações com string"""

# Commented out IPython magic to ensure Python compatibility.
'''
Cartilha: https://drive.google.com/file/d/1IXS85au1DNiddRkiKBpiD8SnDjZV8j_h/view

str            transforma número em string
in             verifica se um texto está contido dentro do outro
operador +     concatenar string
format e {}    substitui valores
# %s             substitui textos
# %d             substitui números decimais
+              Serve para concatenar strings
in e not       Servem para fazer verificações em string
len()          Calcula o tamanho do texto (quantidade de caracteres)
capitalize()   Coloca a 1ª letra Maiúscula
casefold()     Transforma todas as letras em minúsculas (existe lower() mas o casefold é melhor normalmente)
count()	       Quantidade de vezes que um valor aparece na string
endswith()     Verifica se o texto termina com um valor específico e dá como resposta True ou False
find()         Procura um texto dentro de outro texto e dá como resposta a posição do texto encontrado
format()       Formata uma string de acordo com os valores passados. Já usamos bastante ao longo do programa.
isalnum()      Verifica se um texto é todo feito com caracteres alfanuméricos (letras e números) -> letras com acento ou ç são considerados letras para essa função.
isalpha()      Verifica se um texto é todo feito de letras.
isnumeric()	   Verifica se um texto é todo feito por números.
replace()      Substitui um texto por um outro texto em uma string.
split()	       Separa uma string de acordo com um delimitador em vários textos diferentes.
splitlines()   Separa um texto em vários textos de acordo com os "enters" do texto
startswith()   Verifica se a string começa com determinado texto
strip()	       Retira caracteres indesejados dos textos. Por padrão, retira espaços "extras" no início e no final
title()        Coloca a 1ª letra de cada palavra em maiúscula
upper()	       Coloca o texto todo em letra maiúscula
sort()         Organizar

list(map(funcao, lista))    o map recebe 2 infos, a função q quer executar para cada item do iterable. Precisa do list antes p transformar o q quermos em lista

lambda         função anonima. Executa apenas uma linha de código
'''

"""> Funções"""

'''
#Cartilha: https://drive.google.com/file/d/1ACr4_GJjUqGhLSQaoh8-Vq3HyFYSKn2z/view

:<		Alinha o texto à esquerda (se tiver espaço na tela para isso)
:>		Alinha o texto à direita (se tiver espaço na tela para isso)
:^		Alinha o texto ao centro (se tiver espaço na tela para isso)
:+		Coloca o sinal sempre na frente do número (independente se é positivo ou negativo)
:,		Coloca a vírgula como separador de milhar
:_		Coloca o _ como separador de milhar
:e		Formato Científico
:f		Número com quantidade fixa de casas decimais
:x		Formato HEX minúscula (para cores)
:X		Formato HEX maiúscula (para cores)
:%		Formato Percentual
'''

""">Criar uma function
- A function pode ter várias ações e dar uma lista/dicionario como resposta, que poderemos usar posteriormente.
- Podemos fazer uma function que retorna um valor armazenando numa variável
- Uma variavel criada DENTRO da function, só existe dentro dela. Se for usar essa variável depois, pode dar erro dizendo que não foi definida. Por isso usar o return

```
def nome_função():
  faça alguma coisa
  faça outra coisa
  return valor_final
```


```
def minha_soma(num1, num2, num3):
    return num1 + num2 + num3

soma = minha_soma(10, 20, 0)
print(soma)
```

> Lambda
"""

'''
Função anonima que faz uma unica ação
  variavel = lambda parametro: expressao

'''

"""##### Listas, Tuplas e Dicionários"""

'''
list.append(valor)            Adiciona um valor ao final de uma lista
list.append(valor)            Adiciona um valor ao final de uma lista
list.insert(posicao, valor)   Adiciona um valor em uma posição específica em uma lista. Não é recomendado usar a não ser que seja realmente necessário inserir em uma posição específica, porque o método append é mais eficiente.
list.remove(valor)            Remove o valor da lista (apenas a 1ª ocorrência, então caso haja 2 vezes o valor na lista, apenas a 1ª será removida). Além disso, dá um erro caso valor não exista dentro da lista.
list.pop(posicao)             Remove o item que está na posicao (índice) passado. Além disso, esse item é dado como resultado do pop, portanto pode ser armazenado em uma variável ou usado para outra coisa na mesma linha de código.
list.pop(posicao)             Remove o item que está na posicao (índice) passado. Além disso, esse item é dado como resultado do pop, portanto pode ser armazenado em uma variável ou usado para outra coisa na mesma linha de código.
list.pop(posicao)             Remove o item que está na posicao (índice) passado. Além disso, esse item é dado como resultado do pop, portanto pode ser armazenado em uma variável ou usado para outra coisa na mesma linha de código.
list.count(valor)             Retorna a quantidade de vezes que o valor aparece na lista
list.count(valor)             Retorna a quantidade de vezes que o valor aparece na lista
list.reverse()                Inverte a ordem dos elementos de uma lista.
list.copy()                   Cria uma cópia da lista original. Outra opção é fazer lista2 = lista1[:]
'''

"""> Tuplas

- É como uma lista, mas ao inves de [] se usa ()
- É imutável (não consegue alterar dentro dessa lista)
- Pode ter varios tipos de variavel, como texto, numero etc (na lista não pode)
- Vantagem: protege os dados para não ser modificado dentro do programa e é + rápido que listas

> Dicionário
```
dicionario = {chave: valor, chave: valor, chave: valor, chave: valor ...}
```
- Ao inves de pegar info por meio de indice, pegamos por uma chave/nome
- Não devem ser usados para pegar itens em uma determinada ordem
- Podem ter valores heterogêneos (vários tipos de valores dentro de um mesmo dicionário: inteiros, strings, listas, etc)
- Chaves são únicas obrigatoriamente
- Mais intuitivos de trabalhar
"""

'''
copy()                          #Cria uma cópia do dicionário
fromkeys(chaves, valor_padrao)  #Pega todos os itens do dicionario individualmente
get(chave)                      #Buscar uma chave (Semelhante a fazer dictionario[chave]
items()                         #Retorna uma lista em que cada item é uma tupla com (chave, valor)
keys()                          #Pegar uma lista com todas as chaves do dicionario
setdefault(chave, valor)        #Retorna o valor da chave passada, mas caso a chave não exista, cria no dicionário o item com a chave e valor passados.
values()                        #Pegar uma lista com todos os valroes do dicionario
del                             #excluir item: del dicionario[chave]
pop                             #tira o item e armazena numa variavel p caso precise
popitem()                       #retira o último item add no dicionário ao mesmo tempo que armazena o item(chave, valor) dele na variável
clear()                         #limpa todos os itens do dicionario sem apagar o dicionario
sort()                          #Colocar em ordem alfabetica
'''
_________________________________________________________________________________________________
'''Adicionar itens no dicionario'''
dicionario = {}
_________________________________________________________________________________________________
'''Modificar itens no dicionario'''
dicionario[chave_ja_existente] = valor
_________________________________________________________________________________________________
'''Transformar dict_listas em listas normais'''
lista_chave = list(dicionario.keys())   #função list
_________________________________________________________________________________________________
'''Tranformar Listas em Dicionários'''
dicionario = dict.fromkeys(lista_chaves, valor)
dicionario = dict.fromkeys(lista_chaves, 0)
print(dicionario)   #vai aparecer as {'chave1':0, 'chave2':0...}

"""> Iterable
- Estrutura que armazena dados que pode ser "iterada"
- Você pode fazer um loop como um FOR dentro dela e ir passando de item a item
- É como um tipo de lista de coisas que você pode ir olhando cada um dos elementos dentro dela.
- Iterable: string, lista, tupla, dicionario, range

##### Range
"""

produtos = ['arroz', 'feijao', 'macarrao', 'atum', 'azeite']
estoque = [50, 100, 20, 5, 80]

#range(tamanho)
for i in range(5):
    print('{}: {} unidades em estoque'.format(produtos[i], estoque[i]))

#range(inicio, fim)
for i in range(1,10):
  print(i)

#range(inicio, fim, passo)

"""##### Set

- Não pode ter valores duplicados
- Não tem ordem fixa
```
meu_set = {valor, valor, valor, valor,...}
```
"""

'''
add               #adiciona um item no set
remove            #retira um item de um set
clear             #retira todos os itens de um set
union             #junta as informações de 2 sets. Se houver algum valor duplicado, ele constará apenas 1 vez no set final
intersection      #pega apenas as informações que existem nos 2 sets ao mesmo tempo
difference        #retorna todas as informações de um set que não fazem parte de outro set
'''

"""##### Data"""

'''
Uma das bibliotecas pra manipular data
outra biblioteca: datetime
tem um marco zero, que calcula a partir de uma data especifica, que neste caso é 1/01/1970 às 00:00:00

time.time ()        #importa o tempo em segundos
time.ctime()        #importa a data em formato UTC (padrão)
time.sleep(x)       #esperar x segundos para continuar rodando o prog
time.gmtime()       #informações detalhadas da data
'''

import time

seg_agr = time.ctime()
print(seg_agr)

"""##### Gráficos"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns			#sempre q importar seaborn DEVE importar matplotlib
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.ensemble import RandomForestRegressor
from sklearn import metrics

tabela = pd.read_csv('.csv')
display(tabela)

# corr é de correlação, Wistia é um padrão de cores (há outros no site) e annot é para permitir valores da correlaçãop no mapa
sns.heatmap(tabela.corr(), cmap='Wistia', annot=True)		
plt.show()

#separar as infos em infos x (resto)e y (parte que quero descobrir)
y = tabela ['Vendas']
x = tabela.drop('Vendas', axis=1)
#separa o banco para parte ser de teste e parte de treino, para pode prever. Padrão é 80% e 20%, mas para mudar, depois do (x,y, test_size=0.3) que é 70 30% ou outra %
x_treino, x_teste, y_treino, y_teste = train_test_split(x,y)		

modelo_reglinear = LinearRegression ()
modelo_randomforest = RandomForestRegressor()
modelo_reglinear.fit(x_treino, y_treino)
modelo_randomforest.fit(x_treino, y_treino)

previsao_reglinear = modelo_reglinear.predict(x_teste)
previsao_randomforest = modelo_randomforest.predict(x_teste)

print(metrics.r2_score(y_teste, previsao_reglinear))
print(metrics.r2_score(y_teste, previsao_randomforest))
#escolher o modelo com valor mais proximo de 100%, porque ele é melhor para prever nesse caso

tabela_aux = pd.DataFrame()
tabela_aux['y_teste'] = y_teste
tabela_aux['reg linear'] = previsao_reglinear
tabela_aux['random forest'] = previsao_randomforest
plt.show()

"""##### Manipulação de dados"""

#Churn - Quando deixa de ser cliente

#1.
# Importar dados
import pandas as pd
import plotly.express as px		
tabela = pd.read_csv('nome do arquivo.csv')

# Visualizar a base de dados > Entender infos disponiveis
display(tabela)

#2.
# Colunas inuteis
tabela = tabela.drop('nomecoluna', axis=1)				#função drop precisa de 2 info, a coluna que quer tirar, e o eixo (axis=0 linha axis=1 coluna)
tabela = tabela.drop(['colunax', 'colunay', 'colunaz'], axis=1) 	#quando quer excluir +1 coluna
display(tabela)							#para ver se deu certo excluir

# Valores numéricos que python acha que é texto
print(tabela.info())		#tras as infos da tabela, como a quantidade de linhas, colunas, nomes das colunas, valores preenchidos (non-null), o tipo de valor (Dtype)
#Dtype: object=texto, int64=n°inteiro, float64=n°decimal
tabela['nome coluna'] = pd.to_numeric(tabela['nome coluna'], errors='coerce')	#transformar coluna para n°. O "errors=coerce" informar que se tiver erro, é para ignorar esse valor

# Valores que estão vazio > tratar primeiro colunas vazias e depois linhas vazias
tabela = tabela.dropna(how=all, axis=1)		#excluir valores vazios. Obs: tomar cuidado pra nao deletar info importante sem saber
tabela = tabela.dropna(how=any, axis=0)		#Em "how=" podemos colocar all ou any, all=qnd tds valores sao vazios; any=qnd tem pelo menos 1 valor vazio


#4.
# Análise exploratória > Análise geral > Ver como estão os cancelamentos
display(tabela['coluna'].value_counts())					#conta os valores daquela coluna
display(tabela['coluna'].value_counts(normalize=True))				#normalize=True mostra os valores em %
display(tabela['coluna'].value_counts(normalize=True).map('{:.1%}'.formart))	#: é para dizer que quero formatar, o 1 é pra fazer a casa decimal

#https://plotly.com/python/histograms/	
#https://plotly.com/python/statistical-charts/
coluna1 = 'coluna_x'
grafico1 = px.histogram(tabela, x=coluna1, color='coluna_a')		#mostra um gráfico com a coluna que quer, mudando a cor por outra coluna
grafico1.show()
coluna2 = 'coluna_y'
grafico2 = px.histogram(tabela, x=coluna2, color='coluna_a')
grafico2.show()

#para não ficar fazendo vários códigos na mão, podemos automatizar
for coluna in tabela.columns:		#permite rodar um código várias vezes, aqui significa "para cada coluna dessa tabela, rode o codigo abaixo)
	print(coluna)			#os códigos em tab (espaçados) permite que o código entr no for
	grafico = px.histogram(tabela, x=coluna, color='coluna_a')
	grafico.show()


#5.
# Olhando as colunas da base de dados > identificar o motivo dos clientes cancelaren

"""##### List Comprehensions"""

'''
Para cada item da minha lista, faça uma outra lista, e faz o code em basicamente 1 linha
  lista = [expressão for item in iterable]
usado qnd queremos fazer uma ação percorrer cada item de uma lista

para filtrar
  lista = [expressão for item in iterable if condição]
'''

preco_produtos = [100, 150, 300, 5500]
produtos = ['vinho', 'cafeiteira', 'microondas', 'iphone']

'''
#Ao inves de fazer
for preco in preco_produtos:
  imposto.append(preco * 0.3)
print(imposto)
Dá pra fazer esse code em 1 linha
'''

imposto = [preco * 0.3 for preco in preco_produtos]
print(imposto)

'''
Se cada item de uma lista está ligada a outro item de outra lista, algumas funções que organizam as listas podem bagunçar os itens e essa ligação não é a mesma
lista3 = zip(lista1, lista2)    #zip ele junta as 2 listas
Se organizar agr uma lista, a outra irá mudar junto. Como a opção filtro do excel, que temos que colocar filtro nas colunas que queremos manter juntas
'''
vendas_produtos = [1500, 150, 2100, 1950]
produtos = ['vinho', 'cafeiteira', 'microondas', 'iphone']

lista3 = list(zip(vendas_produtos, produtos))
lista3.sort()

produtos = [prod for vendas, prod in lista3]
print(produtos)