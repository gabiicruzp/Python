# -*- coding: utf-8 -*-
"""Python.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1z-rAEzoeqTEuh2y-E69qThgJzAZfJ7Q-

> Bibliotecas
"""

import pandas as pd
import pathlib
import numpy as np                      #trab c numero
import seaborn as sns
import matplotlib.pyplot as plt         #gráficos
import plotly.express as px
from sklearn.metrics import r2_score, mean_squared_error
from sklearn.linear_model import LinearRegression
from sklearn.ensemble import RandomForestRegressor, ExtraTreesRegressor
from sklearn.model_selection import train_test_split

'''
Se alguma biblioteca der probelma na importação:
- Abrir o prompt do Anaconda    -> não confundir com o prompt do pc
- Instalar com o pip
   > pip install pacote
'''

"""> input: pegar info do usuário
```
variavel = input('Pergunta para ser respondida')
```

> Comparadores
"""

'''
==    igual
!=    diferente
>     maior que (>= maior ou igual)
<     menor que (<= menor ou igual)
in    texto existe dentro de outro texto 
not   verifica o contrário da comparação
pass  se em alguma condição você não quiser fazer nada
'''

"""> Operações com string"""

# Commented out IPython magic to ensure Python compatibility.
'''
Cartilha: https://drive.google.com/file/d/1IXS85au1DNiddRkiKBpiD8SnDjZV8j_h/view

str            transforma número em string
in             verifica se um texto está contido dentro do outro
operador +     concatenar string
format e {}    substitui valores
# %s             substitui textos
# %d             substitui números decimais
+              Serve para concatenar strings
in e not       Servem para fazer verificações em string
len()          Calcula o tamanho do texto (quantidade de caracteres)
capitalize()   Coloca a 1ª letra Maiúscula
casefold()     Transforma todas as letras em minúsculas (existe lower() mas o casefold é melhor normalmente)
count()	       Quantidade de vezes que um valor aparece na string
endswith()     Verifica se o texto termina com um valor específico e dá como resposta True ou False
find()         Procura um texto dentro de outro texto e dá como resposta a posição do texto encontrado
format()       Formata uma string de acordo com os valores passados. Já usamos bastante ao longo do programa.
isalnum()      Verifica se um texto é todo feito com caracteres alfanuméricos (letras e números) -> letras com acento ou ç são considerados letras para essa função.
isalpha()      Verifica se um texto é todo feito de letras.
isnumeric()	   Verifica se um texto é todo feito por números.
replace()      Substitui um texto por um outro texto em uma string.
split()	       Separa uma string de acordo com um delimitador em vários textos diferentes.
splitlines()   Separa um texto em vários textos de acordo com os "enters" do texto
startswith()   Verifica se a string começa com determinado texto
strip()	       Retira caracteres indesejados dos textos. Por padrão, retira espaços "extras" no início e no final
title()        Coloca a 1ª letra de cada palavra em maiúscula
upper()	       Coloca o texto todo em letra maiúscula
sort()         Organizar

list(map(funcao, lista))    o map recebe 2 infos, a função q quer executar para cada item do iterable. Precisa do list antes p transformar o q quermos em lista

lambda         função anonima. Executa apenas uma linha de código
'''

"""> Funções"""

'''
#Cartilha: https://drive.google.com/file/d/1ACr4_GJjUqGhLSQaoh8-Vq3HyFYSKn2z/view

:<		Alinha o texto à esquerda (se tiver espaço na tela para isso)
:>		Alinha o texto à direita (se tiver espaço na tela para isso)
:^		Alinha o texto ao centro (se tiver espaço na tela para isso)
:+		Coloca o sinal sempre na frente do número (independente se é positivo ou negativo)
:,		Coloca a vírgula como separador de milhar
:_		Coloca o _ como separador de milhar
:e		Formato Científico
:f		Número com quantidade fixa de casas decimais
:x		Formato HEX minúscula (para cores)
:X		Formato HEX maiúscula (para cores)
:%		Formato Percentual
'''

""">Criar uma function
- A function pode ter várias ações e dar uma lista/dicionario como resposta, que poderemos usar posteriormente.
- Podemos fazer uma function que retorna um valor armazenando numa variável
- Uma variavel criada DENTRO da function, só existe dentro dela. Se for usar essa variável depois, pode dar erro dizendo que não foi definida. Por isso usar o return

```
def nome_função():
  faça alguma coisa
  faça outra coisa
  return valor_final
```


```
def minha_soma(num1, num2, num3):
    return num1 + num2 + num3

soma = minha_soma(10, 20, 0)
print(soma)
```

> Lambda
"""

'''
Função anonima que faz uma unica ação
  variavel = lambda parametro: expressao

'''

"""##### Listas, Tuplas e Dicionários"""

'''
list.append(valor)            Adiciona um valor ao final de uma lista
list.append(valor)            Adiciona um valor ao final de uma lista
list.insert(posicao, valor)   Adiciona um valor em uma posição específica em uma lista. Não é recomendado usar a não ser que seja realmente necessário inserir em uma posição específica, porque o método append é mais eficiente.
list.remove(valor)            Remove o valor da lista (apenas a 1ª ocorrência, então caso haja 2 vezes o valor na lista, apenas a 1ª será removida). Além disso, dá um erro caso valor não exista dentro da lista.
list.pop(posicao)             Remove o item que está na posicao (índice) passado. Além disso, esse item é dado como resultado do pop, portanto pode ser armazenado em uma variável ou usado para outra coisa na mesma linha de código.
list.pop(posicao)             Remove o item que está na posicao (índice) passado. Além disso, esse item é dado como resultado do pop, portanto pode ser armazenado em uma variável ou usado para outra coisa na mesma linha de código.
list.pop(posicao)             Remove o item que está na posicao (índice) passado. Além disso, esse item é dado como resultado do pop, portanto pode ser armazenado em uma variável ou usado para outra coisa na mesma linha de código.
list.count(valor)             Retorna a quantidade de vezes que o valor aparece na lista
list.count(valor)             Retorna a quantidade de vezes que o valor aparece na lista
list.reverse()                Inverte a ordem dos elementos de uma lista.
list.copy()                   Cria uma cópia da lista original. Outra opção é fazer lista2 = lista1[:]
'''

"""> Tuplas

- É como uma lista, mas ao inves de [] se usa ()
- É imutável (não consegue alterar dentro dessa lista)
- Pode ter varios tipos de variavel, como texto, numero etc (na lista não pode)
- Vantagem: protege os dados para não ser modificado dentro do programa e é + rápido que listas

> Dicionário
```
dicionario = {chave: valor, chave: valor, chave: valor, chave: valor ...}
```
- Ao inves de pegar info por meio de indice, pegamos por uma chave/nome
- Não devem ser usados para pegar itens em uma determinada ordem
- Podem ter valores heterogêneos (vários tipos de valores dentro de um mesmo dicionário: inteiros, strings, listas, etc)
- Chaves são únicas obrigatoriamente
- Mais intuitivos de trabalhar
"""

'''
copy()                          #Cria uma cópia do dicionário
fromkeys(chaves, valor_padrao)  #Pega todos os itens do dicionario individualmente
get(chave)                      #Buscar uma chave (Semelhante a fazer dictionario[chave]
items()                         #Retorna uma lista em que cada item é uma tupla com (chave, valor)
keys()                          #Pegar uma lista com todas as chaves do dicionario
setdefault(chave, valor)        #Retorna o valor da chave passada, mas caso a chave não exista, cria no dicionário o item com a chave e valor passados.
values()                        #Pegar uma lista com todos os valroes do dicionario
del                             #excluir item: del dicionario[chave]
pop                             #tira o item e armazena numa variavel p caso precise
popitem()                       #retira o último item add no dicionário ao mesmo tempo que armazena o item(chave, valor) dele na variável
clear()                         #limpa todos os itens do dicionario sem apagar o dicionario
sort()                          #Colocar em ordem alfabetica
'''
_________________________________________________________________________________________________
'''Adicionar itens no dicionario'''
dicionario = {}
_________________________________________________________________________________________________
'''Modificar itens no dicionario'''
dicionario[chave_ja_existente] = valor
_________________________________________________________________________________________________
'''Transformar dict_listas em listas normais'''
lista_chave = list(dicionario.keys())   #função list
_________________________________________________________________________________________________
'''Tranformar Listas em Dicionários'''
dicionario = dict.fromkeys(lista_chaves, valor)
dicionario = dict.fromkeys(lista_chaves, 0)
print(dicionario)   #vai aparecer as {'chave1':0, 'chave2':0...}

"""> Iterable
- Estrutura que armazena dados que pode ser "iterada"
- Você pode fazer um loop como um FOR dentro dela e ir passando de item a item
- É como um tipo de lista de coisas que você pode ir olhando cada um dos elementos dentro dela.
- Iterable: string, lista, tupla, dicionario, range

##### Range
"""

produtos = ['arroz', 'feijao', 'macarrao', 'atum', 'azeite']
estoque = [50, 100, 20, 5, 80]

#range(tamanho)
for i in range(5):
    print('{}: {} unidades em estoque'.format(produtos[i], estoque[i]))

#range(inicio, fim)
for i in range(1,10):
  print(i)

#range(inicio, fim, passo)

"""##### Set

- Não pode ter valores duplicados
- Não tem ordem fixa
```
meu_set = {valor, valor, valor, valor,...}
```
"""

'''
add               #adiciona um item no set
remove            #retira um item de um set
clear             #retira todos os itens de um set
union             #junta as informações de 2 sets. Se houver algum valor duplicado, ele constará apenas 1 vez no set final
intersection      #pega apenas as informações que existem nos 2 sets ao mesmo tempo
difference        #retorna todas as informações de um set que não fazem parte de outro set
'''

"""##### Data"""

'''
Uma das bibliotecas pra manipular data
outra biblioteca: datetime
tem um marco zero, que calcula a partir de uma data especifica, que neste caso é 1/01/1970 às 00:00:00

time.time ()        #importa o tempo em segundos
time.ctime()        #importa a data em formato UTC (padrão)
time.sleep(x)       #esperar x segundos para continuar rodando o prog
time.gmtime()       #informações detalhadas da data
'''

import time

seg_agr = time.ctime()
print(seg_agr)

"""##### Gráficos"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns			#sempre q importar seaborn DEVE importar matplotlib
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.ensemble import RandomForestRegressor
from sklearn import metrics

tabela = pd.read_csv('.csv')
display(tabela)

# corr é de correlação, Wistia é um padrão de cores (há outros no site) e annot é para permitir valores da correlaçãop no mapa
sns.heatmap(tabela.corr(), cmap='Wistia', annot=True)		
plt.show()

#separar as infos em infos x (resto)e y (parte que quero descobrir)
y = tabela ['Vendas']
x = tabela.drop('Vendas', axis=1)
#separa o banco para parte ser de teste e parte de treino, para pode prever. Padrão é 80% e 20%, mas para mudar, depois do (x,y, test_size=0.3) que é 70 30% ou outra %
x_treino, x_teste, y_treino, y_teste = train_test_split(x,y)		

modelo_reglinear = LinearRegression ()
modelo_randomforest = RandomForestRegressor()
modelo_reglinear.fit(x_treino, y_treino)
modelo_randomforest.fit(x_treino, y_treino)

previsao_reglinear = modelo_reglinear.predict(x_teste)
previsao_randomforest = modelo_randomforest.predict(x_teste)

print(metrics.r2_score(y_teste, previsao_reglinear))
print(metrics.r2_score(y_teste, previsao_randomforest))
#escolher o modelo com valor mais proximo de 100%, porque ele é melhor para prever nesse caso

tabela_aux = pd.DataFrame()
tabela_aux['y_teste'] = y_teste
tabela_aux['reg linear'] = previsao_reglinear
tabela_aux['random forest'] = previsao_randomforest
plt.show()

"""##### Navegar na internet


"""

#1. Entrar na internet
import panda as pd
from selenium import webdriver
navegador = webdriver.Chrome()
#selenium normalmente espera o site carregar, não precisa pedir segundos como time.sleep 

#2. Pegar cotação dólar
navegador.get('https://www.google.com.br/')
navegador.find_element_by_xpath('/html/body/div[1]/div[3]/form/div[1]/div[1]/div[1]/div/div[2]/input').send_keys('cotação dolar')		#procura o elemento da página para ser mais especifico
##clicar com botão direito do mouse > inspecionar > 1 botão da aba que abrir que tem um quadrado e uma seta e clicar > passar o mouse na pagina para achar o que queremos, clicar, vai aparecer o que queremos, copiar o codigo que aparece e cola no código acima
## o send_keys é para dizer o que queremos digitar naquele path. 
## Ou seja, podemos abrir o google e pesquisar algo na internet
navegador.find_element_by_xpath('/html/body/div[1]/div[3]/form/div[1]/div[1]/div[1]/div/div[2]/input').send_keys('Keys.ENTER')			#Da enter no site para rodar a busca

cotacao_dolar= navegador.find_element_by_xpath('').get_attribute('data-value')	#colocar o xpath do que queremos, no caso, o valor do $ (data-value, ta escrito no xpath dele)
print(cotacao_dolar)

#3. Pegar cotação euro
navegador.get('https://www.google.com.br/')
navegador.find_element_by_xpath('/html/body/div[1]/div[3]/form/div[1]/div[1]/div[1]/div/div[2]/input').send_keys('cotação euro')
navegador.find_element_by_xpath('/html/body/div[1]/div[3]/form/div[1]/div[1]/div[1]/div/div[2]/input').send_keys('Keys.ENTER')
			
cotacao_euro= navegador.find_element_by_xpath('').get_attribute('data-value')	
print(cotacao_euro)

#4. Pegar cotação ouro
navegador.get('https://www.melhorcambio.com/ouro-hoje')
navegador.find_element_by_xpath('//*[@id="comercial"]').get.attribute('value')
print(cotacao_euro)

#5. Fechar aba
navegador.quit()

#6. Importar e atualziar a base de dados
tabela = pd.read_excel('')
display(tabela)

##atualizar cotação
###tabela.loc[tabela["coluna_referencia"] == linha_ref, coluna_alterar]
tabela.loc[tabela["Moeda"] == 'Dólar', 'Cotação'] = float(cotacao_dolar)
tabela.loc[tabela["Moeda"] == 'Dólar', 'Cotação'] = float(cotacao_euro)
tabela.loc[tabela["Moeda"] == 'Dólar', 'Cotação'] = float(cotacao_ouro)
display(tabela)

##atualizar Preço de Compra > Preço original*cotação
tabela['Preço de Compra'] = tabela['Preço Original'] * tabela ['Cotação']
display(tabela)

##atualizar Preço de vende > preço de compra*margem
tabela['Preço de Vende'] = tabela['Preço Compra'] * tabela ['Margem']
display(tabela)

#7. Exportar a base de dados atualizada
tabela.to_excel('.xlsx')



"""##### Enviar e-mail automaticamente"""

#1) Abrir o Jupyter no PC, aguardar ele abrir uma janela no Chrome. No Chrome aparece as pastas do PC
#2) Criar uma nova pasta para trabalhar

pyautogui: biblioteca de automação de comandos do mouse e teclado
Comandos pyautogui = http://pyautogui.readthedocs.io/en/latest/quickstart.html

#1) Abrir Jupyter, intalar: pip install pyautogui. Só precisa fazer isso 1 única vez
import pyautogui 
import pyperclip	#sempre importar esse com o pyautogui, porque eles atuam juntos. Quando instala o pyautogui, já é instalado o pyperclip
import time 
import pandas as pd	#o "as pd" é para abreviar a biblioteca para qnd for usar só escrever pd

#2) Escrever os passos que fariamos a mão para manipular os dados. Isso ajuda a pensar nos códigos e no que fazer:

#3) Transformar o que queremos em códigos


#Passo 1: entrar no nosso sistema - https://drive.google.com/drive/folders/149xknr9JvrlEnhNWO49zPcw0PW5icxga?usp=sharing
pyautogui.PAUSE = 1		#As vezes da erro o código porque vai muito rápido e o PC não consegue "raciocionar direito". Tem que pedir para o código dar alguns segundos entre comandos

pyautogui.hotkey('ctrl', 't') #Atalho de combinação de tecla para abrir nova aba do chrome

#Criar variável Link e armazenar o link do que queremos. Se tiver mais de um link, separar de alguma forma
link = 'https://drive.google.com/drive/folders/149xknr9JvrlEnhNWO49zPcw0PW5icxga?usp=sharing'
pyperclip.copy('link')	#O pyautogui não lê caractere, ele não consegue rodar quando tem. Isso pode causar problema caso entre em algum site ou alguma frase com caractere. Para isso podemos pedir para a biblioteca pyperclip copiar e colar o que queremos
##no exemplo da aula, o link que ele tenta abrir abaixo tem um ? no meio, e por isso não abre.

pyautogui.hotkey('ctrl', 'v')	#Para colar o Link que foi copiado,

#OU
# pyautogui.press('win')	#Para pressionar uma tecla (win é de windowns #Abrir o programa do PC (press para apertar botão do teclado)
# pyautogui.write('chrome')	#Para o programa escrever
# pyautogui.press('enter')
##fazer o mesmo código que anteriormente

#Passo 2: Entrar na pasta "exportar"
#Para clicar em algum local na tela, precisa saber exatamente em que posição da tela (x,y) para clicar
time.sleep(5)	
pyautogui.position()	#Rodar APENAS essas 2 linhas separadas, e quando rodar, abrir na pag que quer descobrir a localização, e colocar o mouse sobre o botão que quer clicar. Assim, no tempo determinado, ele vai rodar o position()
##Só precisa disso 1x para ver a posição do botão.

time.sleep(5) 		#espera 5seg (uma vez) para o site carregar direito
pyautogui.click(x=478, y=317)	#por padrão isso clica uma única vez
pyautogui.click(x=478, y=317, clicks=2) #agora irá clicar 2x	
##se quiser com botão direto, colocar após a posição (..., button='right')

#Passo 3: Baixar o arquivo da pasta, "arquivo de vendas"
Queremos baixar o arquivo, para isso, quando tiver dentro da pasta, iremos pedir para esperar alguns segundos para carregar a pag. E terá pelo menos 3 clicks (clicar no arquivo, clicar nos 3 pontinhos, clicar em download)
##Localizar cada botão
time.sleep(5)
pyautogui.position()
###fazer isso para cada parte que deverá ser clicado e salvar a posição

time.sleep (3)
pyautogui.click(x=478, y=317)	#para 1° click
pyautogui.click(x=478, y=317)	#para 2° click
pyautogui.click(x=478, y=317)	#para 3° click
time.sleep (10)	#para esperar fazer o download

#Passo 4: Importar arquivo
##Com botão direito do mouse, no arquivo que está no PC, clicar em propriedades para achar em que local do PC está o arquivo que queremos importar

tabela = pd.read_excel(r'C:\Users\Gabriela\Downloads\Curso Python\Hashtag\Aula1\Vendas -Dez.xlsx')
##o "r" antes do C: faz com que o diretório seja lido exatamente como está, é uma dica
tabela.head()
display(tabela)	#mostra a tabela formatada bonitinha

#Passo 5: O que precisa ser manipulado: calcular faturamento e qnt de prod vendidos
faturamento = tabela['Valor Final'].sum() 
quantidade = tabela['Quantidade'].sum
print(faturamento)
print(quantidade)

#Passo 6: Enviar email
link2 = 'https://outlook.live.com/mail/0/inbox'
pyperclip.copy(link2)
pyautogui.hotkey('ctrl', 't')
pyautogui.write('crtk', 'v')
pyautogui.press('enter')

time.sleep (3)

#clicar botão nova mensagem
pyautogui.click(x=478, y=317)	#para 1° click no "nova mensagem"
#escrever pra quem estou enviando
pyautogui.write('')
pyautogui.press('tab')	#para selecionar o email que escreveu
pyautogui.press('tab')	#para ir para o assunto

#escrever assunto
pyautogui.write('')
pyautogui.press('tab')
pyautogui.press('tab')
pyautogui.press('tab')	#para ir para o corpo do email
#obs: se tiver caractere especial, precisa colocar o texto em variavel:
#> assunto = "Relatório"
#> pyperclip.copy(assunto)
#> pyautogui.hotkey('ctrl','v')
#> pyautogui.press('tab')

#escrever corpo do email
texto = f"""
textotextotexto textotexto {variável que queremos colocar:,.2f}
texto texto texto {outra variável:,.2f}

Abraços,
Gabriela C.
"""
##as 3 aspas seguidas permite escrever em várias linhas, e a letra f antes da aspas informa que vamos formartar o texto. Já as chaves {} permite colocar a variavel que queremos formatar dentro do texto. Se colocar : após a variavel, é para editar aquela variavel naquele momento, ex quando precisar mudar n°. A virgula é o separador de milhar, ".2f" é para dizer que tem 2 casas decimais.
pyautogui.write(texto)

#enviar email
pyautogui.click(x=478, y=317)	#para 2° click	#clicar em enviar

import pyautogui
import pyperclip
import time
import pandas as pd

#time.sleep(5)
#pyautogui.position()

pyautogui.PAUSE = 1

pyautogui.hotkey('ctrl','t')
link1= 'https://outlook.live.com/mail/0/inbox'
pyperclip.copy(link1)
pyautogui.hotkey('ctrl', 'v')
pyautogui.press('enter')

time.sleep (3)

pyautogui.click(x=205, y=213)

time.sleep (5)

texto1 = 'gabrielacruzp@hotmail.com'
pyperclip.copy(texto1)

pyautogui.hotkey('ctrl','v')
pyautogui.press('tab')
pyautogui.press('tab')
pyautogui.press('tab')

assunto = 'Recado de Paçoca Paiva'
pyperclip.copy(assunto)
pyautogui.hotkey('ctrl', 'v')
pyautogui.press('tab')

texto2 = """

"""
pyperclip.copy(texto2)
pyautogui.hotkey('ctrl','v')

pyautogui.click(x=327, y=769)

"""##### Manipulação de dados"""

#Churn - Quando deixa de ser cliente

#1.
# Importar dados
import pandas as pd
import plotly.express as px		
tabela = pd.read_csv('nome do arquivo.csv')

# Visualizar a base de dados > Entender infos disponiveis
display(tabela)

#2.
# Colunas inuteis
tabela = tabela.drop('nomecoluna', axis=1)				#função drop precisa de 2 info, a coluna que quer tirar, e o eixo (axis=0 linha axis=1 coluna)
tabela = tabela.drop(['colunax', 'colunay', 'colunaz'], axis=1) 	#quando quer excluir +1 coluna
display(tabela)							#para ver se deu certo excluir

# Valores numéricos que python acha que é texto
print(tabela.info())		#tras as infos da tabela, como a quantidade de linhas, colunas, nomes das colunas, valores preenchidos (non-null), o tipo de valor (Dtype)
#Dtype: object=texto, int64=n°inteiro, float64=n°decimal
tabela['nome coluna'] = pd.to_numeric(tabela['nome coluna'], errors='coerce')	#transformar coluna para n°. O "errors=coerce" informar que se tiver erro, é para ignorar esse valor

# Valores que estão vazio > tratar primeiro colunas vazias e depois linhas vazias
tabela = tabela.dropna(how=all, axis=1)		#excluir valores vazios. Obs: tomar cuidado pra nao deletar info importante sem saber
tabela = tabela.dropna(how=any, axis=0)		#Em "how=" podemos colocar all ou any, all=qnd tds valores sao vazios; any=qnd tem pelo menos 1 valor vazio


#4.
# Análise exploratória > Análise geral > Ver como estão os cancelamentos
display(tabela['coluna'].value_counts())					#conta os valores daquela coluna
display(tabela['coluna'].value_counts(normalize=True))				#normalize=True mostra os valores em %
display(tabela['coluna'].value_counts(normalize=True).map('{:.1%}'.formart))	#: é para dizer que quero formatar, o 1 é pra fazer a casa decimal

#https://plotly.com/python/histograms/	
#https://plotly.com/python/statistical-charts/
coluna1 = 'coluna_x'
grafico1 = px.histogram(tabela, x=coluna1, color='coluna_a')		#mostra um gráfico com a coluna que quer, mudando a cor por outra coluna
grafico1.show()
coluna2 = 'coluna_y'
grafico2 = px.histogram(tabela, x=coluna2, color='coluna_a')
grafico2.show()

#para não ficar fazendo vários códigos na mão, podemos automatizar
for coluna in tabela.columns:		#permite rodar um código várias vezes, aqui significa "para cada coluna dessa tabela, rode o codigo abaixo)
	print(coluna)			#os códigos em tab (espaçados) permite que o código entr no for
	grafico = px.histogram(tabela, x=coluna, color='coluna_a')
	grafico.show()


#5.
# Olhando as colunas da base de dados > identificar o motivo dos clientes cancelaren

"""##### List Comprehensions"""

'''
Para cada item da minha lista, faça uma outra lista, e faz o code em basicamente 1 linha
  lista = [expressão for item in iterable]
usado qnd queremos fazer uma ação percorrer cada item de uma lista

para filtrar
  lista = [expressão for item in iterable if condição]
'''

preco_produtos = [100, 150, 300, 5500]
produtos = ['vinho', 'cafeiteira', 'microondas', 'iphone']

'''
#Ao inves de fazer
for preco in preco_produtos:
  imposto.append(preco * 0.3)
print(imposto)
Dá pra fazer esse code em 1 linha
'''

imposto = [preco * 0.3 for preco in preco_produtos]
print(imposto)

'''
Se cada item de uma lista está ligada a outro item de outra lista, algumas funções que organizam as listas podem bagunçar os itens e essa ligação não é a mesma
lista3 = zip(lista1, lista2)    #zip ele junta as 2 listas
Se organizar agr uma lista, a outra irá mudar junto. Como a opção filtro do excel, que temos que colocar filtro nas colunas que queremos manter juntas
'''
vendas_produtos = [1500, 150, 2100, 1950]
produtos = ['vinho', 'cafeiteira', 'microondas', 'iphone']

lista3 = list(zip(vendas_produtos, produtos))
lista3.sort()

produtos = [prod for vendas, prod in lista3]
print(produtos)

