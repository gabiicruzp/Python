# -*- coding: utf-8 -*-
"""Biopython.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mnpJmTtDdG51XsKppJZ37o29TLldkpeU

O comando 'if' permite criar blocos de comando onde SE aquela condição for verdadeira, então será executado aquele código. Mas também podemos colocar comando como 'else' e 'elif' para caso aquela condição do 'if' inicial não seja verdade, executar então um secundo código (ou então ignorar o código e pular, por exemplo)
"""

# Ex: Criar um if para imprimir uma frase caso o eleitor possa ou não votar
## Idades obrigatórias que podem votar de 18 a 70 anos, e facultativo de 16 a 18

idade = 70

if idade >= 0 and idade < 16:
  print("Vc ainda nao pode votar")

elif (idade >=16 and idade <18 or idade >= 70):
  print("Vc pode votar, mas não é obrigatório")

elif (idade >= 18 and idade < 70):
 print("Vc deve votar obrigatóriamente!")

else:
  print("idade inválida")

# Ex: Comparar se 2 sequencias são iguais

seq1 = input('Digite a sequencia 1:')
seq2 = input('Digite a sequencia 2:')

if seq1 == seq2: 
  print('As sequencias são iguais')
else:
  print('As sequencias são diferentes')

import re

seq1 = input('Digite a sequencia 1:')
seq2 = input('Digite a sequencia 2:')

busca = re.match(seq1,seq2)

if busca:
  print('sequencias identicas')
  print(busca.group())
else: 
  print('sequencias diferentes')

#ex: usando função map para atribuir uma função a cada item de uma lista

def dobro(x):
  return x*2

valor = [1, 2, 3, 4, 5]

valor_dobrado = map(dobro, valor)

for v in valor_dobrado:
  print(v)

#ou ao inves de usar for v in valor_dobrado

valor_dobrado = list(valor_dobrado)
print(valor_dobrado)

#Entretanto, ao inves de criar uma função def, podemos usar a função lambda para criar a função no qual usaremos apenas uma vez
valor2 = [10, 20, 30, 40, 50]
valor_dobrado2 = map(lambda i:i*2, valor2)
# na funcao lambda ela vai receber a função na msm linha, onde eu adiciono i e para cada valor (que estarei colocando em i) será aplicado essa função, que no caso é i*2

valor_dobrado2 = list(valor_dobrado2)
print(valor_dobrado2)

#precisa rodar essa linha de comando para poder usar o Bio.Seq no google colab
!pip3 install biopython

#Biopython: modulo de analise de sequencias
from Bio.Seq import Seq

#no biopython sequencias são declaradas como objetos e não string, e por isso precisa chamar a sequencia usando "Seq"
seq = Seq('ACGTAGCTACGATCACAGCTA')
print(seq)

#Sequencia complementar reversa 
cr = seq.reverse_complement()            #ACGUAGCUACGAUCACAGCUA
print('O reverso complementar é', cr)

#Transcrição
rna = seq.transcribe()
print('O RNA é', rna)

#Transcrição reversa
dna = rna.back_transcribe()
print('O DNA da transcrição reversa é', dna)

#Tradução
protein = seq.translate()
print("Sequencia de proteinas é", protein)
#Tradução de fita de DNA
protein_dna = rna.back_transcribe()

#Reverter sequencia 
print('Reverter sequencia:')
print('A seq original é', seq)
print('A seq reversa é', seq[::-1])    #onde [posicao de inicio:posicao final:passo]
  #como posicao de inicio e final esta em branco, todas as letras sao usadas, e o -1 indica que a seq deve ser inversa

#Receber o indice de cada valor da sequencia
for i, n in enumerate(seq):
  print(i, n)

#Podemos converter objetos de sequencias em strings usando str() e converter string em objeto de sequencia usando Seq()
seq2 = str(seq)
print(type(seq2))

seq3 = Seq(seq2)
print(type(seq3))

from Bio.SeqUtils import GC

print('Conteudo CG')
print(GC(seq))

"""Usando arquivos FASTA: cada sequencia é indicada por um cabeçalho iniciado pelo simbolo >

Precisamos usar o modulo SeqIO e precisamos enviar o arquivo FASTA para o Colab. Podemos evniar abrindo a aba lateral esquerda, indo em arquivos e evniar a sequencia

"""

from Bio import SeqIO 

#criar um laço (?) para ler todo arquivo de sequencia
for fasta in SeqIO.parse('seq.fast', 'fasta'):
  print(fasta.id)
  print(fasta.seq)

#Manipulação de estrutura de proteinas com Biopython
import numpy as np
from Bio.PDB import *

#Isso lê a estrutura 3D de uma proteina e converte em objeto do tipo structure, que entende por meio de uma hierarquia (SMCRA - structure models chains residues atomns), fazendo várias camadas e permitindo que nós navegamos por essas camadas
#1. Acessar o site PDB (protein data bank)
#2. Faz download em "PDB format"
#3. Coloca o arquivo na mesma pasta que o script

parser = PDBParser()
est1 = parser.get_structure('1BGA', '1bga.pdb')     #vc dá o nome da proteina e depois coloca o nome do arquivo como foi salvo
'''
est1 = est1[0]      #estrutura na posicao 0
cadeia_a = est1['A']    #para acessar no modelo a posicao A
residuo_100 = cadeia_a[100]
atomo = residuo_100['CA']    #CA de carbono alfa
'''
#ou
atomo_100 = est1[0]['A'][100]['CA']
atomo_101 = est1[0]['A'][101]['CA']

#Distancia euclidiana (entre 2 atomos)
dist = atomo_101 - atomo_100    #supondo que tenha feito code para atomo_101
print(dist)
print('A distancia entre o CA do residuo 101 e 100 é:', dist)

#Comparar sequencia de RNA ribossomal entre humanos e bactérias
##https://www.ncbi.nlm.nih.gov/nuccore/M10098.1?report=fasta
##https://www.ncbi.nlm.nih.gov/nuccore/NR_024570.1?report=fasta
entrada = open("16s_bacteria.fasta").read()
saida = open("16s_bacteria.html","w")

cont = {}

#O code abaixo vai criar o dicionario de par em par, ou seja, AA,AT,AC,AG,TA,TT,TC,TG... (sao 16 combinacoes)
for i in ['A', 'T', 'C', 'G']:
	for j in ['A', 'T', 'C', 'G']:
		cont[i+j] = 0

entrada = entrada.replace("\n","")    #o arquivo fasta tem quebras de linha que interfere nos codigos

#O code abaixo percorre o fasta e ver a qnt de nucleotideos
for k in range(len(entrada)-1):             #percorre de 0 ate tamanho, que no caso é 1469 nucleotideos
	cont[entrada[k]+entrada[k+1]] += 1        #+=1 soma no dicionario


##entrada na posicao k[0] é =A, que é 1° valor da sequencia
##entrada na posicao k+1 é = G, que é 2° valor da sequencia
###então, [entrada[k]+entrada[k+1] = AG]   -> adiciona 1 no dicionário em AG

print(cont)



# html: usado para criar o 'grafico' de comparacao
saida.write("<div>")

i = 1
for k in cont:
	transparencia = cont[k]/max(cont.values())              #pega todos os valores, vê qual é o maior, faz a divisao da transparencia. O mais colorido é o maior valor
	saida.write("<div style='width:100px; border:1px solid #111; color:#fff; height:100px; float:left; background-color:rgba(0, 0, 0, "+str(transparencia)+"')>"+k+"</div>")

	if i%4 == 0:                                            #vai quebrar o html a cada 4 (porque temos 16 combinacoes)
		saida.write("<div style='clear:both'></div>")

	i+=1

saida.close()

#teoricamente deveria ter um arquivo html onde a gente abre na internet e ve 4x4 quadrados
#achei esse arquivo onde importei os dados, fiz download e abri

#fazer para humanos
entrada = open("18s_humano.fasta").read()
saida = open("18s_humano.html","w")

cont = {}

#O code abaixo vai criar o dicionario de par em par, ou seja, AA,AT,AC,AG,TA,TT,TC,TG... (sao 16 combinacoes)
for i in ['A', 'T', 'C', 'G']:
	for j in ['A', 'T', 'C', 'G']:
		cont[i+j] = 0

entrada = entrada.replace("\n","")    #o arquivo fasta tem quebras de linha que interfere nos codigos

#O code abaixo percorre o fasta e ver a qnt de nucleotideos
for k in range(len(entrada)-1):             #percorre de 0 ate tamanho, que no caso é 1469 nucleotideos
	cont[entrada[k]+entrada[k+1]] += 1        #+=1 soma no dicionario


##entrada na posicao k[0] é =A, que é 1° valor da sequencia
##entrada na posicao k+1 é = G, que é 2° valor da sequencia
###então, [entrada[k]+entrada[k+1] = AG]   -> adiciona 1 no dicionário em AG

print(cont)



# html: usado para criar o 'grafico' de comparacao
saida.write("<div>")

i = 1
for k in cont:
	transparencia = cont[k]/max(cont.values())              #pega todos os valores, vê qual é o maior, faz a divisao da transparencia. O mais colorido é o maior valor
	saida.write("<div style='width:100px; border:1px solid #111; color:#fff; height:100px; float:left; background-color:rgba(0, 0, 0, "+str(transparencia)+"')>"+k+"</div>")

	if i%4 == 0:                                            #vai quebrar o html a cada 4 (porque temos 16 combinacoes)
		saida.write("<div style='clear:both'></div>")

	i+=1

saida.close()

#teoricamente deveria ter um arquivo html onde a gente abre na internet e ve 4x4 quadrados
#achei esse arquivo onde importei os dados, fiz download e abri

#Bases de dados biológicos

#PDB protein data bank
#ZINC base de moleculas ligantes
#UniProt base de dados de sequencia de proteinas (tem swiss prot (tem info manualmente anotada e revisada) e TrEMBL (não foram revisadas))
#GenBank do NCBI
#SRA armazena dados brutos de sequenciamento
#Pfam armazena coleção de familia de proteinas

#Alinhamento sequencias







## https://bioinfo.com.br/biopython-uma-breve-introducao-a-manipulacao-de-dados-biologicos-em-python-usando-colab/
from Bio import SeqIO 
from Bio.SeqRecord import SeqRecord
import re

gravar = []

for i in SeqIO.parse("seq.fasta", "fasta"):
  nome = i.id
  descricao = i.description
  seq = i.seq 

  # coletando o id do uniprot
 
  id_uniprot = re.findall('\|.*\|', descricao)
  id_uniprot = id_uniprot[0].replace("|", "")

  # seqrecord 
  
  aux = SeqRecord(
      seq, 
      id = id_uniprot,
      description=""
  )
  gravar.append(aux)

  # criando um novo arquivo fasta 

SeqIO.write(
    gravar,
    "seq2.fasta",
    "fasta"
)